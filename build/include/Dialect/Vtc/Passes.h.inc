/* Autogenerated by mlir-tblgen; don't manually edit */
#ifdef GEN_PASS_CLASSES

//===----------------------------------------------------------------------===//
// CombineToIfElsePass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class CombineToIfElsePassBase : public ::mlir::FunctionPass {
public:
  CombineToIfElsePassBase() : ::mlir::FunctionPass(::mlir::TypeID::get<DerivedT>()) {}
  CombineToIfElsePassBase(const CombineToIfElsePassBase &) : ::mlir::FunctionPass(::mlir::TypeID::get<DerivedT>()) {}

  /// Returns the command-line argument attached to this pass.
  ::llvm::StringRef getArgument() const override { return "vtc-combine-to-ifelse"; }

  /// Returns the derived pass name.
  ::llvm::StringRef getName() const override { return "CombineToIfElsePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

protected:
  ::mlir::Pass::Option<bool> prepareOnly{*this, "prepare-only", ::llvm::cl::desc("Lower extra operands and fuse multiple producers attached to one combine"), ::llvm::cl::init(false)};
  ::mlir::Pass::Option<bool> internalOnly{*this, "internal-only", ::llvm::cl::desc("Lower only combine ops embedded in between apply ops"), ::llvm::cl::init(false)};
};

//===----------------------------------------------------------------------===//
// DomainSplitPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class DomainSplitPassBase : public ::mlir::FunctionPass {
public:
  DomainSplitPassBase() : ::mlir::FunctionPass(::mlir::TypeID::get<DerivedT>()) {}
  DomainSplitPassBase(const DomainSplitPassBase &) : ::mlir::FunctionPass(::mlir::TypeID::get<DerivedT>()) {}

  /// Returns the command-line argument attached to this pass.
  ::llvm::StringRef getArgument() const override { return "vtc-domain-split"; }

  /// Returns the derived pass name.
  ::llvm::StringRef getName() const override { return "DomainSplitPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

protected:
};

//===----------------------------------------------------------------------===//
// PeelOddIterationsPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class PeelOddIterationsPassBase : public ::mlir::FunctionPass {
public:
  PeelOddIterationsPassBase() : ::mlir::FunctionPass(::mlir::TypeID::get<DerivedT>()) {}
  PeelOddIterationsPassBase(const PeelOddIterationsPassBase &) : ::mlir::FunctionPass(::mlir::TypeID::get<DerivedT>()) {}

  /// Returns the command-line argument attached to this pass.
  ::llvm::StringRef getArgument() const override { return "vtc-peel-odd-iterations"; }

  /// Returns the derived pass name.
  ::llvm::StringRef getName() const override { return "PeelOddIterationsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

protected:
};

//===----------------------------------------------------------------------===//
// ShapeInferencePass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class ShapeInferencePassBase : public ::mlir::FunctionPass {
public:
  ShapeInferencePassBase() : ::mlir::FunctionPass(::mlir::TypeID::get<DerivedT>()) {}
  ShapeInferencePassBase(const ShapeInferencePassBase &) : ::mlir::FunctionPass(::mlir::TypeID::get<DerivedT>()) {}

  /// Returns the command-line argument attached to this pass.
  ::llvm::StringRef getArgument() const override { return "vtc-shape-inference"; }

  /// Returns the derived pass name.
  ::llvm::StringRef getName() const override { return "ShapeInferencePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

protected:
  ::mlir::Pass::Option<bool> extendStorage{*this, "extend-storage", ::llvm::cl::desc("Extend the shape of store and buffer ops"), ::llvm::cl::init(false)};
};

//===----------------------------------------------------------------------===//
// ShapeOverlapPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class ShapeOverlapPassBase : public ::mlir::FunctionPass {
public:
  ShapeOverlapPassBase() : ::mlir::FunctionPass(::mlir::TypeID::get<DerivedT>()) {}
  ShapeOverlapPassBase(const ShapeOverlapPassBase &) : ::mlir::FunctionPass(::mlir::TypeID::get<DerivedT>()) {}

  /// Returns the command-line argument attached to this pass.
  ::llvm::StringRef getArgument() const override { return "vtc-shape-overlap"; }

  /// Returns the derived pass name.
  ::llvm::StringRef getName() const override { return "ShapeOverlapPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

protected:
};

//===----------------------------------------------------------------------===//
// StorageMaterializationPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class StorageMaterializationPassBase : public ::mlir::FunctionPass {
public:
  StorageMaterializationPassBase() : ::mlir::FunctionPass(::mlir::TypeID::get<DerivedT>()) {}
  StorageMaterializationPassBase(const StorageMaterializationPassBase &) : ::mlir::FunctionPass(::mlir::TypeID::get<DerivedT>()) {}

  /// Returns the command-line argument attached to this pass.
  ::llvm::StringRef getArgument() const override { return "vtc-storage-materialization"; }

  /// Returns the derived pass name.
  ::llvm::StringRef getName() const override { return "StorageMaterializationPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

protected:
};

//===----------------------------------------------------------------------===//
// VtcInliningPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class VtcInliningPassBase : public ::mlir::FunctionPass {
public:
  VtcInliningPassBase() : ::mlir::FunctionPass(::mlir::TypeID::get<DerivedT>()) {}
  VtcInliningPassBase(const VtcInliningPassBase &) : ::mlir::FunctionPass(::mlir::TypeID::get<DerivedT>()) {}

  /// Returns the command-line argument attached to this pass.
  ::llvm::StringRef getArgument() const override { return "vtc-inlining"; }

  /// Returns the derived pass name.
  ::llvm::StringRef getName() const override { return "VtcInliningPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

protected:
};

//===----------------------------------------------------------------------===//
// VtcUnrollingPass
//===----------------------------------------------------------------------===//

template <typename DerivedT>
class VtcUnrollingPassBase : public ::mlir::FunctionPass {
public:
  VtcUnrollingPassBase() : ::mlir::FunctionPass(::mlir::TypeID::get<DerivedT>()) {}
  VtcUnrollingPassBase(const VtcUnrollingPassBase &) : ::mlir::FunctionPass(::mlir::TypeID::get<DerivedT>()) {}

  /// Returns the command-line argument attached to this pass.
  ::llvm::StringRef getArgument() const override { return "vtc-unrolling"; }

  /// Returns the derived pass name.
  ::llvm::StringRef getName() const override { return "VtcUnrollingPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    
  }

protected:
  ::mlir::Pass::Option<unsigned> unrollFactor{*this, "unroll-factor", ::llvm::cl::desc("Number of unrolled loop iterations"), ::llvm::cl::init(2)};
  ::mlir::Pass::Option<unsigned> unrollIndex{*this, "unroll-index", ::llvm::cl::desc("Unroll index specifying the unrolling dimension"), ::llvm::cl::init(1)};
};
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES
#ifdef GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// CombineToIfElsePass Registration
//===----------------------------------------------------------------------===//

inline void registerCombineToIfElsePassPass() {
  ::mlir::registerPass("vtc-combine-to-ifelse", "Lower vtc combine ops to if/else", []() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createCombineToIfElsePass();
  });
}

//===----------------------------------------------------------------------===//
// DomainSplitPass Registration
//===----------------------------------------------------------------------===//

inline void registerDomainSplitPassPass() {
  ::mlir::registerPass("vtc-domain-split", "Copy apply ops used in multiple domains", []() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createDomainSplitPass();
  });
}

//===----------------------------------------------------------------------===//
// PeelOddIterationsPass Registration
//===----------------------------------------------------------------------===//

inline void registerPeelOddIterationsPassPass() {
  ::mlir::registerPass("vtc-peel-odd-iterations", "Peel odd iterations that are not a multiple of the unroll factor", []() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createPeelOddIterationsPass();
  });
}

//===----------------------------------------------------------------------===//
// ShapeInferencePass Registration
//===----------------------------------------------------------------------===//

inline void registerShapeInferencePassPass() {
  ::mlir::registerPass("vtc-shape-inference", "Infer loop bounds and storage shapes", []() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createShapeInferencePass();
  });
}

//===----------------------------------------------------------------------===//
// ShapeOverlapPass Registration
//===----------------------------------------------------------------------===//

inline void registerShapeOverlapPassPass() {
  ::mlir::registerPass("vtc-shape-overlap", "Handle overlapping stores", []() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createShapeOverlapPass();
  });
}

//===----------------------------------------------------------------------===//
// StorageMaterializationPass Registration
//===----------------------------------------------------------------------===//

inline void registerStorageMaterializationPassPass() {
  ::mlir::registerPass("vtc-storage-materialization", "Introduce explicit storage between combine and apply ops", []() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createStorageMaterializationPass();
  });
}

//===----------------------------------------------------------------------===//
// VtcInliningPass Registration
//===----------------------------------------------------------------------===//

inline void registerVtcInliningPassPass() {
  ::mlir::registerPass("vtc-inlining", "Inline vtc apply ops", []() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createVtcInliningPass();
  });
}

//===----------------------------------------------------------------------===//
// VtcUnrollingPass Registration
//===----------------------------------------------------------------------===//

inline void registerVtcUnrollingPassPass() {
  ::mlir::registerPass("vtc-unrolling", "Unroll vtc apply ops", []() -> std::unique_ptr<::mlir::Pass> {
    return mlir::createVtcUnrollingPass();
  });
}

//===----------------------------------------------------------------------===//
// Vtc Registration
//===----------------------------------------------------------------------===//

inline void registerVtcPasses() {
  registerCombineToIfElsePassPass();
  registerDomainSplitPassPass();
  registerPeelOddIterationsPassPass();
  registerShapeInferencePassPass();
  registerShapeOverlapPassPass();
  registerStorageMaterializationPassPass();
  registerVtcInliningPassPass();
  registerVtcUnrollingPassPass();
}
#undef GEN_PASS_REGISTRATION
#endif // GEN_PASS_REGISTRATION
