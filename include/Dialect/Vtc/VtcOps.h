#ifndef DIALECT_Vtc_VtcOPS_H
#define DIALECT_Vtc_VtcOPS_H

#include "Dialect/Vtc/VtcTypes.h"
#include "Dialect/Vtc/VtcUtils.h"
#include "Dialect/Vtc/VtcDialect.h"
#include "mlir/IR/Attributes.h"
#include "mlir/IR/BuiltinOps.h"
#include "mlir/IR/MLIRContext.h"
#include "mlir/IR/PatternMatch.h"
#include "mlir/Interfaces/SideEffectInterfaces.h"
#include "mlir/Support/LogicalResult.h"
#include <cstdint>
#include <numeric>

namespace mlir {
namespace Vtc {
#include "Dialect/Vtc/ShapeInterface.h.inc"
#include "Dialect/Vtc/OffsetInterface.h.inc"
#include "Dialect/Vtc/ShiftInterface.h.inc"
#include "Dialect/Vtc/ExtentInterface.h.inc"
} // namespace Vtc
} // namespace mlir

/// Retrieve the class declarations generated by TableGen
#define GET_OP_CLASSES
#include "Dialect/Vtc/VtcOps.h.inc"

namespace mlir {
namespace Vtc {

    // Base class for the Vtc apply op canonicalization
struct ApplyOpPattern : public OpRewritePattern<Vtc::ApplyOp> {
  ApplyOpPattern(MLIRContext *context, PatternBenefit benefit = 1);

  Vtc::ApplyOp cleanupOpArguments(Vtc::ApplyOp applyOp,
                                      PatternRewriter &rewriter) const;
};

// Base class for the Vtc combine op canonicalization
struct CombineOpPattern : public OpRewritePattern<Vtc::CombineOp> {
  CombineOpPattern(MLIRContext *context, PatternBenefit benefit = 1);

  Vtc::ApplyOp createEmptyApply(Vtc::CombineOp combineOp,
                                    int64_t lowerLimit, int64_t upperLimit,
                                    ValueRange values,
                                    PatternRewriter &rewriter) const;
};
} // namespace Vtc
} // namespace mlir

#endif // DIALECT_Vtc_VtcOPS_H
